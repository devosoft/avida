######## Meta Events ###########
exit
:descr:
/**
* Ends the Avida run immediately.
**/
:args:
:body:
cAvidaDriver_Base::main_driver->SetDone();

exit_if_generation_greater_than
:descr:
/**
* Ends the Avida run when the current generation exceeds the
* maximum generation given as parameter.
*
* Parameters:
* max generation (int)
*   The generation at which the run should be stopped.
**/
:args:
int max_generation
:body:
if( population->GetGeneration() > max_generation ){
  cAvidaDriver_Base::main_driver->SetDone();
}

exit_if_update_greater_than
:descr:
/**
* Ends the Avida run when the current update exceeds the
* maximum update given as parameter.
*
* Parameters:
* max update (int)
*   The update at which the run should be stopped.
**/
:args:
int max_update
:body:
if( population->GetUpdate() > max_update ){
  cAvidaDriver_Base::main_driver->SetDone();
}


exit_if_ave_lineage_label_smaller
:descr:
/**
* Halts the avida run if the current average lineage label is smaller
* than the value given as parameter.
*
* Parameters:
* lineage_label_crit_value (int)
*   The critical value to which the average lineage label is compared.
**/
:args:
double lineage_label_crit_value
:body:
if( population->GetStats().GetAveLineageLabel() < lineage_label_crit_value ){
  cAvidaDriver_Base::main_driver->SetDone();
}

exit_if_ave_lineage_label_larger
:descr:
/**
* Halts the avida run if the current average lineage label is larger
* than the value given as parameter.
*
* Parameters:
* lineage_label_crit_value (int)
*   The critical value to which the average lineage label is compared.
**/
:args:
double lineage_label_crit_value
:body:
if( population->GetStats().GetAveLineageLabel() > lineage_label_crit_value ){
  cAvidaDriver_Base::main_driver->SetDone();
}

echo
:descr:
/**
* Writes out a message. If no message is given, average update and
* generation are written out.
*
* Parameters:
* message (string)
**/
:args:
cString mesg
:body:
if( mesg == "" ){
   mesg.Set("Echo : Update = %f\t AveGeneration = %f",
	     population->GetUpdate(), population->GetGeneration());
}
cAvidaDriver_Base::main_driver->NotifyComment(mesg);

####### Printing Data Files ###########
print_data
:descr:
/**
* Output user-defined data from the cStats object...
*
* Parameters:
* filename (string)
*   The name of the data file.
* format
*   A comma-seperated list of statistics to output.
**/
:args:
cString filename
cString format
:body:
population->GetStats().PrintDataFile(filename, format, ',');

print_average_data
:descr:
/**
* Output various average quantities into datafile.
*
* Parameters:
* filename (string) default: average.dat
*   The name of the data file.
**/
:args:
cString fname "average.dat"
:body:
population->GetStats().PrintAverageData(fname);

print_error_data
:descr:
/**
* Prints out various data related to statistical errors.
*
* Parameters:
* filename (string) default: error.dat
*   The name of the data file.
**/
:args:
cString fname "error.dat"
:body:
population->GetStats().PrintErrorData(fname);

print_variance_data
:descr:
/**
* Prints out various variances.
*
* Parameters:
* filename (string) default: variance.dat
*   The name of the data file.
**/
:args:
cString fname "variance.dat"
:body:
population->GetStats().PrintVarianceData(fname);

print_dominant_data
:descr:
/**
* Output various quantities related to the dominant organism.
*
* Parameters:
* filename (string) default: dominant.dat
*   The name of the data file.
**/
:args:
cString fname "dominant.dat"
:body:
population->GetStats().PrintDominantData(fname);

print_stats_data
:descr:
/**
* Output various statistical quantities.
*
* Parameters:
* filename (string) default: stats.dat
*   The name of the data file.
**/
:args:
cString fname "stats.dat"
:body:
population->GetStats().PrintStatsData(fname);

print_count_data
:descr:
/**
* Output various counts, such as number of organisms etc.
*
* Parameters:
* filename (string) default: count.dat
*   The name of the data file.
**/
:args:
cString fname "count.dat"
:body:
population->GetStats().PrintCountData(fname);

print_totals_data
:descr:
/**
* Various total numbers.
*
* Parameters:
* filename (string) default: totals.dat
*   The name of the data file.
**/
:args:
cString fname "totals.dat"
:body:
population->GetStats().PrintTotalsData(fname);

print_tasks_data
:descr:
/**
* Output the number of times the various tasks have been performed in the
* last update.
*
* Parameters:
* filename (string) default: tasks.dat
*   The name of the data file.
**/
:args:
cString fname "tasks.dat"
:body:
population->GetStats().PrintTasksData(fname);

print_tasks_exe_data
:descr:
/**
**/
:args:
cString fname "tasks_exe.dat"
:body:
population->GetStats().PrintTasksExeData(fname);

print_resource_data
:descr:
/**
**/
:args:
cString fname "resource.dat"
:body:
population->GetStats().PrintResourceData(fname);

print_time_data
:descr:
/**
* Output time related data, such as update, generation, etc.
*
* Parameters:
* filename (string) default: time.dat
*   The name of the data file.
**/
:args:
cString fname "time.dat"
:body:
population->GetStats().PrintTimeData(fname);

print_mutation_data
:descr:
/**
**/
:args:
cString fname "mutation.dat"
:body:
population->GetStats().PrintMutationData(fname);

print_mutation_rate_data
:descr:
/**
Output (regular and log) statistics about individual copy
mutation rates (aver, stdev, skew, cur).
Useful only when mutation rate is set per organism.
**/
:args:
cString fname "mutation_rates.dat"
:body:
population->GetStats().PrintMutationRateData(fname);

print_divide_mut_data
:descr:
/**
Output (regular and log) statistics about individual, per site,
rates divide mutation rates (aver, stdev, skew, cur).
Use with multiple divide instuction set.
**/
:args:
cString fname "divide_mut.dat"
:body:
population->GetStats().PrintDivideMutData(fname);

print_dom_parasite_data
:descr:
/**
* Output various quantities related to the dominant parasite.
*
* Parameters:
* filename (string) default: parasite.dat
*   The name of the data file.
**/
:args:
cString fname "parasite.dat"
:body:
population->GetStats().PrintDominantParaData(fname);

######### Instruction Data Output ##############
print_instruction_data
:descr:
/**
Sum of the by-organisms counts of what instructions they _successfully_
execute beteween birth and divide. Prior to their first divide, organisms
report values for their parents.
**/
:args:
cString fname "instruction.dat"
:body:
population->GetStats().PrintInstructionData(fname);

########### Population Instruction Abundance ######
########### ED 2002-Sept-7 #################
print_instruction_abundance_histogram
:descr:
/**
*
* Appends a line containing the bulk count (abundance) of
* each instruction in the population onto a file.
*
* Parameters:
* filename (string) default: "instruction_histogram.dat"
*
**/
:args:
cString filename "instruction_histogram.dat"
:body:
ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
cAnalyzeUtil::PrintInstructionAbundanceHistogram(fp, population);



########### Misc Output #################3
print_depth_histogram
:descr:
/**
**/
:args:
cString filename "depth_histogram.dat"
:body:
ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
cAnalyzeUtil::PrintDepthHistogram(fp, population);

print_genotype_abundance_histogram
:descr:
/**
* Writes out a genotype abundance histogram.
*
* Parameters:
* filename (string) default: genotype_abundance_histogram.dat
*   The name of the file into which the histogram is written.
**/
:args:
cString filename "genotype_abundance_histogram.dat"
:body:
ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
cAnalyzeUtil::PrintGenotypeAbundanceHistogram(fp, population);

print_species_abundance_histogram
:descr:
/**
* Writes out a species abundance histogram.
*
* Parameters:
* filename (string) default: species_abundance_histogram.dat
*   The name of the file into which the histogram is written.
**/
:args:
cString filename "species_abundance_histogram.dat"
:body:
ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
cAnalyzeUtil::PrintSpeciesAbundanceHistogram(fp, population);

print_lineage_totals
:descr:
/**
**/
:args:
cString fname "lineage_totals.dat"
int verbose 1
:body:
static bool msg_printed = false;
if (population->GetLineageControl() == NULL) {
  if ( msg_printed == false ){
    ofstream & fp = population->GetStats().GetDataFileOFStream(fname);
    fp << "No lineage data available!" << endl;
    msg_printed = true;
  }
  return;
}
population->GetLineageControl()->PrintLineageTotals(fname, verbose);

print_lineage_counts
:descr:
/**
**/
:args:
cString fname "lineage_counts.dat"
int verbose 0
:body:
static bool msg_printed = false;
if (population->GetLineageControl() == NULL) {
  if ( msg_printed == false ){
    ofstream & fp = population->GetStats().GetDataFileOFStream(fname);
    fp << "No lineage data available!" << endl;
    msg_printed = true;
  }
  return;
}
if (verbose) {    // verbose mode is the same in both methods
  population->GetLineageControl()->PrintLineageTotals(fname, verbose);
  return;
}
population->GetLineageControl()->PrintLineageCurCounts(fname);

print_dom
:descr:
/**
* Write the currently dominant genotype to disk.
*
* Parameters:
* filename (string)
*   The name under which the genotype should be saved. If no
*   filename is given, the genotype is saved into the directory
*   genebank, under the name that the genebank has associated with
*   this genotype.
**/
:args:
cString in_filename ""
:body:
cGenotype * dom = population->GetGenebank().GetBestGenotype();
cString filename(in_filename);
if (filename == "") filename.Set("genebank/%s", dom->GetName()());
cTestUtil::PrintGenome(dom->GetGenome(), filename, dom, population->GetUpdate());

parasite_debug
:descr:
//midget
:args:
cString in_filename ""
:body:
population->ParasiteDebug();

print_dom_parasite
:descr:
/**
* Write the currently dominant injected genotype to disk.
*
* Parameters:
* filename (string)
*   The name under which the genotype should be saved. If no
*   filename is given, the genotype is saved into the directory
*   genebank, under the name that the genebank has associated with
*   this genotype.
**/
:args:
cString in_filename ""
:body:
cInjectGenotype * dom = population->GetInjectGenebank().GetBestInjectGenotype();
if (dom!=NULL) {
cString filename(in_filename);
if (filename == "") filename.Set("genebank/%s", dom->GetName()());
cTestUtil::PrintGenome(dom, dom->GetGenome(), filename, population->GetUpdate()); }

print_genotype_map
:descr:
/**
* write a matrix of genotype ID's to a file (matlab format)
**/
:args:
cString fname "genotype_map.m"
:body:
population->GetStats().PrintGenotypeMap(fname);

print_number_phenotypes
:descr:
/**
Output file with number of phenotypes based on tasks executed
for this update.  Executing a task any numbers of times is considered
the same as executing it once.
**/
:args:
cString fname "phenotype_count.dat"
:body:
population->PrintPhenotypeData(fname);

print_phenotype_status
:descr:
/**
Prints merit status for all the organisms in the population.
Used for testing/debuging. 
**/
:args:
cString fname "phenotype_status.dat"
:body:
population->PrintPhenotypeStatus(fname);

######### SAVE/LOAD POPULATION  ######################
save_population
:descr:
/**
* Saves the full state of the population.
*
* Parameters:
* filename (string) default: save_pop.*
*   The name of the file into which the population should
*   be saved. If it is not given, then the name 'save_pop.*'
*   is used, with '*' replaced by the current update.
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("save_pop.%d", population->GetUpdate());
}
ofstream fp(filename());
population->SavePopulation(fp);

load_population
:descr:
/**
* Loads the full state of the population.
*
* Parameters:
* filename (string)
*   The name of the file to open.
**/
:args:
cString fname
:body:
ifstream fp(fname());
population->LoadPopulation(fp);


######### CLONES ######################
save_clone
:descr:
/**
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("clone.%d", population->GetUpdate());
}
ofstream fp(filename());
population->SaveClone(fp);

load_clone
:descr:
/**
**/
:args:
cString fname
:body:
ifstream fp(fname());
population->LoadClone(fp);


load_dump_file
:descr:
/**
* Sets up a population based on a dump file such as written out by
* detail_pop. It is also possible to append a history file to the dump
* file, in order to preserve the history of a previous run.
**/
:args:
cString fname
int update -1
:body:
population->LoadDumpFile(fname, update);

########## DUMP A TEXT SUMMARY ###########
dump_pop
:descr:
/**
* Writes out a line of data for each genotype in the current population. The
* line contains the genome as string, the number of organisms of that genotype,
* and the genotype ID.
*
* Parameters:
* filename (string) default: "dump.<update>"
*   The name of the file into which the population dump should be written.
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("dump.%d", population->GetUpdate());
}
ofstream fp(filename());
population->GetGenebank().DumpTextSummary(fp);

print_genotypes
:descr:
/**
* This is a new version of "detail_pop" or "historic_dump".  It allows you to
* output one line per genotype in memory where you get to choose what data
* should be included.
*
* Parameters
* data_fields (string)
*   This must be a comma separated string of all data you wish to output.
*   Options include: id, parent_id, parent2_id (for sex), parent_dist,
*       num_cpus, total_cpus, length, merit, gest_time, fitness, update_born,
*       update_dead, depth, lineage, sequence
* historic (int) default: 0
*   How many updates back of history should we include (-1 = all)
* filename (string) default: "genotypes-<update>.dat"
*   The name of the file into which the population dump should be written.
**/
:args:
cString data_fields "all"
int historic 0
cString fname ""
:body:
cString filename = fname;
if (filename == "") {
  filename.Set("genotypes-%d.dat", population->GetUpdate());
}
ofstream fp(filename());
population->GetGenebank().PrintGenotypes(fp, data_fields, historic);

detail_pop
:descr:
/**
* Like dump_pop, but more detailed data is written out.
*
* Parameters:
* filename (string) default: "detail_pop.<update>"
*   The name of the file into which the population dump should be written.
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("detail_pop.%d", population->GetUpdate());
}
ofstream fp(filename());
population->GetGenebank().DumpDetailedSummary(fp);

detail_sex_pop
:descr:
/**
* Like detail_pop, but for sexual populations. 
* Info for both parents is writen out.
*
* Parameters:
* filename (string) default: "detail_pop.<update>"
*   The name of the file into which the population dump should be written.
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("detail_pop.%d", population->GetUpdate());
}
ofstream fp(filename());
population->GetGenebank().DumpDetailedSexSummary(fp);


detail_parasite_pop
:descr:
/**
* Like dump_pop, but more detailed data is written out.
*
* Parameters:
* filename (string) default: "detail_pop.<update>"
*   The name of the file into which the population dump should be written.
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("detail_parasite_pop.%d", population->GetUpdate());
}
//ofstream fp(filename());
population->GetInjectGenebank().DumpDetailedSummary(filename, population->GetUpdate());

dump_historic_pop
:descr:
/**
* Similar to detail_pop. However, only genotypes that are not in the
* current population anymore are included. Genotypes that are not in
* the line of descent of any of the current genotypes to the ultimate
* ancestor are excluded.
*
* Parameters:
* back_dist (int) default: -1
*   How many updates back should we print?  -1 goes forever.  Use the
*   distance to the last dump historic if you only want a "diff".
* filename (string) default: "historic_dump.<update>"
*   The name of the file into which the historic dump should be written.
**/
:args:
int back_dist -1
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("historic_dump.%d", population->GetUpdate());
}
ofstream fp(filename());
population->GetGenebank().DumpHistoricSummary(fp, back_dist);

dump_historic_sex_pop
:descr:
/**
* Similar to dump_historic_pop, but for sexual populations. 
* ID of both parents is writen out. 
*
* Parameters:
* filename (string) default: "historic_dump.<update>"
*   The name of the file into which the historic dump should be written.
**/
:args:
cString fname ""
:body:
cString filename;
if( fname == "" ){
  filename.Set("historic_dump.%d", population->GetUpdate());
}
ofstream fp(filename());
population->GetGenebank().DumpHistoricSexSummary(fp);

dump_memory
:descr:
/**
* Dump the current memory state of all CPUs to a file.
**/
:args:
cString fname ""
:body:
cString filename;
if (fname == "") {
  filename.Set("memory_dump.%d", population->GetUpdate());
}
ofstream fp(filename());
population->DumpMemorySummary(fp);

################ INJECT ###################
inject
:descr:
/**
* Injects a single organism into the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* cell ID (integer) default: 0
*   The grid-point into which the organism should be placed.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
**/
:args:
cString fname "START_CREATURE"
int cell_id 0
double merit -1
int lineage_label 0
double neutral_metric 0
:body:
if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
cGenome genome =
   cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
population->Inject(genome, cell_id, merit, lineage_label, neutral_metric);

inject_all
:descr:
/**
* Injects identical organisms into all cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
**/
:args:
cString fname "START_CREATURE"
double merit -1
int lineage_label 0
double neutral_metric 0
:body:
if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
cGenome genome =
   cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
for (int i = 0; i < population->GetSize(); i++) {
  population->Inject(genome, i, merit, lineage_label, neutral_metric);
}
population->SetSyncEvents(true);

inject_range
:descr:
/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range creature.gen 0 10
*
* Will inject 10 organisms into cells 0 through 9.
**/
:args:
cString fname "START_CREATURE"
int start_cell 0
int end_cell -1
double merit -1
int lineage_label 0
double neutral_metric 0
:body:
if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
if (end_cell == -1) end_cell = start_cell + 1;
if (start_cell < 0 ||
    end_cell > population->GetSize() ||
    start_cell >= end_cell) {
  cout << "Warning: inject_range has invalid range!";
}
else {
  cGenome genome =
     cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
  for (int i = start_cell; i < end_cell; i++) {
    population->Inject(genome, i, merit, lineage_label, neutral_metric);
  }
  population->SetSyncEvents(true);
}

inject_sequence
:descr:
/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* sequence (string)
*   The genome sequence for this organism.  This is a mandatory argument.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range ckdfhgklsahnfsaggdsgajfg 0 10 100
*
* Will inject 10 organisms into cells 0 through 9 with a merit of 100.
**/
:args:
cString seq
int start_cell 0
int end_cell -1
double merit -1
int lineage_label 0
double neutral_metric 0
:body:
if (end_cell == -1) end_cell = start_cell + 1;
if (start_cell < 0 ||
    end_cell > population->GetSize() ||
    start_cell >= end_cell) {
  cout << "Warning: inject_sequence has invalid range!" << endl;
  cout << "start=" << start_cell << "  end=" << end_cell
       << "genome length=" << seq.GetSize() << endl;
}
else {
  cGenome genome(seq);
  for (int i = start_cell; i < end_cell; i++) {
    population->Inject(genome, i, merit, lineage_label, neutral_metric);
  }
  population->SetSyncEvents(true);
}

inject_random
:descr:
/**
* Injects a randomly generated genome into the population.
*
* Parameters:
* length (integer) [required]
*   Number of instructions in the randomly generated genome.
* cell ID (integer) default: -1
*   The grid-point into which the genome should be placed.  Default is random.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
**/
:args:
int length
int cell_id -1
double merit -1
int lineage_label 0
double neutral_metric 0
:body:
if (cell_id == -1) cell_id = g_random.GetUInt(population->GetSize());
cGenome genome =
   cInstUtil::RandomGenome(length, population->GetEnvironment().GetInstSet());
population->Inject(genome, cell_id, merit, lineage_label, neutral_metric);

inject_range_parasite
:descr:
/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range creature.gen 0 10
*
* Will inject 10 organisms into cells 0 through 9.
**/
:args:
cString fname_parasite "organism.parasite"
int start_cell 0
int end_cell -1
double merit -1
int lineage_label 0
double neutral_metric 0
int mem_space 2
:body:
if (fname_parasite == "START_CREATURE") fname_parasite=cConfig::GetStartCreature();
if (end_cell == -1) end_cell = start_cell + 1;
if (start_cell < 0 ||
    end_cell > population->GetSize() ||
    start_cell >= end_cell) {
  cout << "Warning: inject_range has invalid range!";
}
else {
  cGenome genome_parasite =
     cInstUtil::LoadGenome(fname_parasite, population->GetEnvironment().GetInstSet());
  for (int i = start_cell; i < end_cell; i++) {
    population->Inject(genome_parasite, i, merit, lineage_label, neutral_metric, mem_space);
  }
  population->SetSyncEvents(true);
}

inject_range_pair
:descr:
/**
* Injects identical organisms into a range of cells of the population.
*
* Parameters:
* filename (string)
*   The filename of the genotype to load. If this is left empty, or the keyword
*   "START_CREATURE" is given, than the genotype specified in the genesis
*   file under "START_CREATURE" is used.
* start_cell (int)
*   First cell to inject into.
* stop_cell (int)
*   First cell *not* to inject into.
* merit (double) default: -1
*   The initial merit of the organism. If set to -1, this is ignored.
* lineage label (integer) default: 0
*   An integer that marks all descendants of this organism.
* neutral metric (double) default: 0
*   A double value that randomly drifts over time.
*
* Example:
*   inject_range creature.gen 0 10
*
* Will inject 10 organisms into cells 0 through 9.
**/
:args:
cString fname "START_CREATURE"
cString fname_parasite "organism.parasite"
int start_cell 0
int end_cell -1
double merit -1
int lineage_label 0
double neutral_metric 0
int mem_space 2
:body:
if (fname == "START_CREATURE") fname=cConfig::GetStartCreature();
if (end_cell == -1) end_cell = start_cell + 1;
if (start_cell < 0 ||
    end_cell > population->GetSize() ||
    start_cell >= end_cell) {
  cout << "Warning: inject_range has invalid range!";
}
else {
  cGenome genome =
     cInstUtil::LoadGenome(fname, population->GetEnvironment().GetInstSet());
  cGenome genome_parasite =
     cInstUtil::LoadGenome(fname_parasite, population->GetEnvironment().GetInstSet());
  for (int i = start_cell; i < end_cell; i++) {
    population->Inject(genome, i, merit, lineage_label, neutral_metric);
    population->Inject(genome_parasite, i, merit, lineage_label, neutral_metric, mem_space);
  }
  population->SetSyncEvents(true);
}

################ MUTATION RATES ###############
zero_muts
:descr:
/**
 * This event will set all mutation rates to zero...
 **/
:args:
:body:
for (int i = 0; i < population->GetSize(); i++) {
  population->GetCell(i).MutationRates().Clear();
}

mod_copy_mut
:descr:
/**
**/
:args:
double cmut_inc
int cell -1
:body:
const double new_cmut = cConfig::GetCopyMutProb() + cmut_inc;
if (cell < 0) {   // cell == -1  -->  all
  for (int i = 0; i < population->GetSize(); i++) {
    population->GetCell(i).MutationRates().SetCopyMutProb(new_cmut);
  }
  cConfig::SetCopyMutProb(new_cmut);
} else {
  population->GetCell(cell).MutationRates().SetCopyMutProb(new_cmut);
}

mod_div_mut
:descr:
/**
**/
:args:
double dmut_inc
int cell -1
:body:
const double new_div_mut = cConfig::GetDivMutProb() + dmut_inc;
if (cell < 0) {   // cell == -1  -->  all
  for (int i = 0; i < population->GetSize(); i++) {
    population->GetCell(i).MutationRates().SetDivMutProb(new_div_mut);
  }
  cConfig::SetDivMutProb(new_div_mut);
} else {
  population->GetCell(cell).MutationRates().SetDivMutProb(new_div_mut);
}


set_copy_mut
:descr:
/**
**/
:args:
double cmut
int start_cell -1
int end_cell -1
:body:
if (start_cell < 0) {   // start_cell == -1  -->  all
  cConfig::SetCopyMutProb(cmut);
  start_cell = 0;
  end_cell = population->GetSize();
}
else if (end_cell < -1)  { // end_cell == -1 --> Only one cell!
  end_cell = start_cell + 1;
}
assert(start_cell >= 0 && start_cell < population->GetSize());
assert(end_cell > 0 && end_cell <= population->GetSize());
for (int i = start_cell; i < end_cell; i++) {
  population->GetCell(i).MutationRates().SetCopyMutProb(cmut);
}

mod_point_mut
:descr:
/**
**/
:args:
double pmut_inc
int cell -1
:body:
const double new_pmut = cConfig::GetPointMutProb() + pmut_inc;
if (cell < 0) {   // cell == -1   -->  all
  for (int i = 0; i < population->GetSize(); i++) {
    population->GetCell(i).MutationRates().SetPointMutProb(new_pmut);
  }
  cConfig::SetPointMutProb(new_pmut);
} else {
  population->GetCell(cell).MutationRates().SetPointMutProb(new_pmut);
}

set_point_mut
:descr:
/**
**/
:args:
double pmut
int cell -1
:body:
if (cell < 0) {   // cell == -1   -->  all
  for (int i = 0; i < population->GetSize(); i++) {
    population->GetCell(i).MutationRates().SetPointMutProb(pmut);
  }
  cConfig::SetPointMutProb(pmut);
} else {
  population->GetCell(cell).MutationRates().SetPointMutProb(pmut);
}

######## Landscapeing #########
calc_landscape
:descr:
/**
**/
:args:
int landscape_dist  1
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cAnalyzeUtil::CalcLandscape(landscape_dist, genome,
                            population->GetEnvironment().GetInstSet());

predict_w_landscape
:descr:
/**
**/
:args:
cString datafile "land-predict.dat"
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
static ofstream fp(datafile);
landscape.PredictWProcess(fp);

predict_nu_landscape
:descr:
/**
**/
:args:
cString datafile "land-predict.dat"
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
static ofstream fp(datafile);
landscape.PredictNuProcess(fp);

sample_landscape
:descr:
/**
**/
:args:
int sample_size 0
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
if (sample_size == 0) sample_size = population->GetEnvironment().GetInstSet().GetSize() - 1;
landscape.SampleProcess(sample_size);
static ofstream fp("land-sample.dat");
landscape.PrintStats(fp, population->GetUpdate());

random_landscape
:descr:
/**
**/
:args:
int landscape_dist  1
int sample_size     0
int min_found       0
int max_sample_size 0
bool print_if_found  false
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
landscape.RandomProcess(sample_size, landscape_dist, min_found,
                        max_sample_size, print_if_found);
static ofstream fp("land-random.dat");
landscape.PrintStats(fp, population->GetUpdate());

analyze_landscape
:descr:
/**
**/
:args:
int sample_size     1000
int min_found       0
int max_sample_size 0
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cAnalyzeUtil::
AnalyzeLandscape(genome, population->GetEnvironment().GetInstSet(),
 		 sample_size, min_found, max_sample_size,
		 population->GetUpdate());

pairtest_landscape
:descr:
/**
* If sample_size = 0, pairtest the full landscape.
**/
:args:
int sample_size 0
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
cAnalyzeUtil::PairTestLandscape(genome, population->GetEnvironment().GetInstSet(), sample_size, population->GetUpdate());

test_dom
:descr:
/**
**/
:args:
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
static ofstream fp("dom-test.dat");
cAnalyzeUtil::TestGenome(genome, population->GetEnvironment().GetInstSet(), fp, population->GetUpdate());

analyze_population
:descr:
/**
**/
:args:
double sample_prob 1
int landscape 0
int save_genotype 0
cString filename ""
:body:
static bool auto_filename = false;
if( filename == "" )
  auto_filename = true;
if ( auto_filename )
  filename.Set("population_info_%d.dat",population->GetUpdate());
ofstream population_info(filename());
cAnalyzeUtil::AnalyzePopulation(population, population_info, sample_prob,
				landscape, save_genotype);

print_detailed_fitness_data
:descr:
/**
**/
:args:
int save_max_f_genotype 0
int print_fitness_histo 0
double hist_fmax 1
double hist_fstep 0.1
cString filename "fitness.dat"
cString filename2 "fitness_histos.dat"
cString filename3 "fitness_histos_testCPU.dat"
:body:
static ofstream datafile(filename());
static ofstream histofile;
static ofstream histofile_testCPU;
if (print_fitness_histo && !histofile.is_open()){
  histofile.open(filename2());
  histofile_testCPU.open(filename3());
}
cAnalyzeUtil::PrintDetailedFitnessData( population, datafile, histofile, histofile_testCPU, save_max_f_genotype, print_fitness_histo, hist_fmax, hist_fstep );

print_genetic_distance_data
:descr:
/**
**/
:args:
cString creature_name ""
cString filename "genetic_distance.dat"
:body:
static ofstream popdump(filename());
if( creature_name == "" || creature_name == "START_CREATURE" ){
  creature_name = cConfig::GetStartCreature(); }
cAnalyzeUtil::PrintGeneticDistanceData( population, popdump, creature_name() );

genetic_distance_pop_dump
:descr:
/**
**/
:args:
cString creature_name ""
cString filename ""
int save_genotype 0
:body:
static bool auto_filename = false;
if( creature_name == "" || creature_name == "START_CREATURE" ){
  creature_name = cConfig::GetStartCreature(); }
if( filename == "" || filename == "AUTO" )
  auto_filename = true;
if ( auto_filename )
  filename.Set("pop_dump_%d.dat",population->GetUpdate());
ofstream popdump(filename());
cAnalyzeUtil::GeneticDistancePopDump( population, popdump, creature_name(), save_genotype );


task_snapshot
:descr:
/**
**/
:args:
cString filename ""
:body:
static bool auto_filename = false;
if( filename == "" )
  auto_filename = true;
if ( auto_filename )
  filename.Set("tasks_%d.dat",population->GetUpdate());
ofstream snapshot_file(filename());
cAnalyzeUtil::TaskSnapshot( population, snapshot_file );

print_viable_tasks_data
:descr:
/**
**/
:args:
cString filename "viable_tasks.dat"
:body:
static ofstream datafile(filename());
cAnalyzeUtil::PrintViableTasksData( population, datafile );


############ Removal of creatures #############
apocalypse
:descr:
/**
* Randomly removes a certain proportion of the population.
*
* Parameters:
* removal probability (double) default: 0.9
*   The probability with which a single organism is removed.
**/
:args:
double kill_prob .9
:body:
for (int i = 0; i < population->GetSize(); i++) {
  cPopulationCell & cell = population->GetCell(i);
  if (cell.IsOccupied() == false) continue;
  if (g_random.P(kill_prob))  population->KillOrganism(cell);
}

kill_rectangle
:descr:
/**
* Kills all cell in a rectangle.
*
* Parameters:
* cell [X1][Y1][x2][Y2] (integer) default: 0
*   The start and stoping grid-points into which the organism should
be killed.
**/
:args:
int cell_X1 0
int cell_Y1 0
int cell_X2 0
int cell_Y2 0
:body:
int i, j, loc;
/* Be sure the user entered a valid range */
if (cell_X1 < 0) {
  cell_X1 = 0;
} else if (cell_X1 > population->GetWorldX() - 1) {
  cell_X1 = population->GetWorldX() - 1;
}
if (cell_X2 < 0) {
  cell_X2 = 0;
} else if (cell_X2 > population->GetWorldX() - 1) {
  cell_X2 = population->GetWorldX() - 1;
}
if (cell_Y1 < 0) {
  cell_Y1 = 0;
} else if (cell_Y1 > population->GetWorldY() - 1) {
  cell_Y1 = population->GetWorldY() - 1;
}
if (cell_Y2 < 0) {
  cell_Y2 = 0;
} else if (cell_Y2 > population->GetWorldY() - 1) {
  cell_Y2 = population->GetWorldY() - 1;
}
/* Account for a rectangle that crosses over the Zero X or Y cell */
if (cell_X2 < cell_X1) {
   cell_X2 = cell_X2 + population->GetWorldX();
}
if (cell_Y2 < cell_Y1) {
   cell_Y2 = cell_Y2 + population->GetWorldY();
}
for (i = cell_Y1; i <= cell_Y2; i++) {
   for (j = cell_X1; j <= cell_X2; j++) {
     loc = (i % population->GetWorldY()) * population->GetWorldX() +
           (j % population->GetWorldX());
     cPopulationCell & cell = population->GetCell(loc);
     if (cell.IsOccupied() == true) {
       population->KillOrganism(cell);
     }
   }
}
population->SetSyncEvents(true);

rate_kill
:descr:
/**
* Randomly removes a certain proportion of the population.
* In principle, this event does the same thing as the apocalypse event.
* However, instead of a probability, here one has to specify a rate. The
* rate has the same unit as fitness. So if the average fitness is 20000,
* then you remove 50% of the population on every update with a removal rate
* of 10000.
*
* Parameters:
* removal rate (double)
*   The rate at which organisms are removed.
**/
:args:
double kill_rate
:body:
double ave_merit = population->GetStats().SumMerit().Average();
if ( ave_merit <= 0 )
  ave_merit = 1; // make sure that we don't get NAN's or negative numbers
ave_merit /= cConfig::GetAveTimeslice();
const double kill_prob = kill_rate / ave_merit;
for (int i = 0; i < population->GetSize(); i++) {
  cPopulationCell & cell = population->GetCell(i);
  if (cell.IsOccupied() == false) continue;
  if (g_random.P(kill_prob))  population->KillOrganism(cell);
}

serial_transfer
:descr:
/**
* This event does again the same thing as apocalypse. However, now
* the number of organisms to be retained can be specified
* exactly. Also, it is possible to specify whether any of these
* organisms may be dead or not.
*
* Parameters:
* transfer size (int) default: 1
*   The number of organisms to retain. If there are fewer living
*   organisms than the specified transfer size, then all living
*   organisms are retained.
* ignore deads (int) default: 1
*   When set to 1, only living organisms are retained. Otherwise,
*   every type of organism can be retained.
**/
:args:
int transfer_size 1
int ignore_deads 1
:body:
population->SerialTransfer( transfer_size, ignore_deads );


############ Hill Climbing #############
hillclimb
:descr:
/**
* Does a hill climb with the dominant genotype.
**/
:args:
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
ofstream fp("hillclimb.dat");
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
landscape.HillClimb(fp);

hillclimb_neut
:descr:
/**
**/
:args:
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
ofstream fp("hillclimb.dat");
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
landscape.HillClimb_Neut(fp);

hillclimb_rand
:descr:
/**
**/
:args:
:body:
cGenome & genome = population->GetGenebank().GetBestGenotype()->GetGenome();
ofstream fp("hillclimb.dat");
cLandscape landscape(genome, population->GetEnvironment().GetInstSet());
landscape.HillClimb_Rand(fp);

############ Demes ###############
compete_demes
:descr:
/**
* Compete all of the demes using a basic genetic algorithm approach. Fitness
* of each deme is determined differently depending on the competition_type: 
* 0: deme fitness = 1 (control, random deme selection)
* 1: deme fitness = number of births since last competition (default) 
* 2: deme fitness = average organism fitness at the current update
* 3: deme fitness = average mutation rate at the current update
* Merit can optionally be passed in.
**/
:args:
int competition_type 1
:body:
population->CompeteDemes(competition_type);

reset_demes
:descr:
/**
* Designed to serve as a control for the compete_demes. Each deme is 
* copied into itself and the parameters reset. 
**/
:args:
:body:
population->ResetDemes();

print_deme_stats
:descr:
/**
* Print stats about individual demes
**/
:args:
:body:
population->PrintDemeStats();

copy_deme
:descr:
/**
* Takes two numbers as arguments and copies the contents of the first deme
* listed into the second.
**/
:args:
int deme1_id
int deme2_id
:body:
population->CopyDeme(deme1_id, deme2_id);

############ Consensus #############
calc_consensus
:descr:
/**
* Calculates the consensus sequence.
*
* Parameters:
* lines saved (integer) default: 0
*    ???
**/
:args:
int lines_saved 0
:body:
cAnalyzeUtil::CalcConsensus(population, lines_saved);

############ Other Population Called Tests ##########
test_size_change_robustness
:descr:
/**
**/
:args:
int num_trials 100
cString filename "size_change.dat"
:body:
ofstream & fp = population->GetStats().GetDataFileOFStream(filename);
cAnalyzeUtil::TestInsSizeChangeRobustness(fp,
		population->GetEnvironment().GetInstSet(),
		population->GetGenebank().GetBestGenotype()->GetGenome(),
		num_trials, population->GetUpdate());

########### Threads ################
test_threads
:descr:
/**
**/
:args:
:body:
cTestCPU::TestThreads(population->GetGenebank().GetBestGenotype()->GetGenome());

print_threads
:descr:
/**
**/
:args:
:body:
cTestCPU::PrintThreads( population->GetGenebank().GetBestGenotype()->GetGenome() );

########### Grid Output ##############
# This event depends on the ncurses viewer (cSymbolUtil).
# That's not good. The event can only be reactivated if that
# dependency is removed. Claus
#dump_basic_grid
#:descr:
#/**
#**/
#:args:
#:body:
#cString filename;
#filename.Set("grid.%	05d.out", population->GetUpdate());
#ofstream fp(filename());
#for (int i = 0; i < population->GetWorldX(); i++) {
#  for (int j = 0; j < population->GetWorldY(); j++) {
#    cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
#    char out_char = cSymbolUtil::GetBasicSymbol(cell);
#    switch (out_char) {
#      case ' ':
#        fp << -3;
#        break;
#      case '.':
#        fp << -2;
#        break;
#      case '+':
#        fp << -1;
#        break;
#      default:
#        fp << out_char - 'A';
#    }
#    fp << " ";
#  }
#  fp << endl;
#}
#
dump_fitness_grid
:descr:
/**
* Writes out all fitness values of the organisms currently in the
* population.
*
* The output file is called "fgrid.*.out", where '*' is replaced by the
* number of the current update.
**/
:args:
:body:
cString filename;
filename.Set("fgrid.%05d.out", population->GetUpdate());
ofstream fp(filename());
for (int i = 0; i < population->GetWorldX(); i++) {
  for (int j = 0; j < population->GetWorldY(); j++) {
    cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
    double fitness = (cell.IsOccupied()) ?
	 cell.GetOrganism()->GetGenotype()->GetFitness() : 0.0;
    fp << fitness << " ";
  }
  fp << endl;
}

dump_genotype_grid
:descr:
/**
* Writes out all genotype id values of the organisms currently in the
* population.
*
* The output file is called "idgrid.*.out", where '*' is replaced by the
* number of the current update.
**/
:args:
:body:
cString filename;
filename.Set("idgrid.%05d.out", population->GetUpdate());
ofstream fp(filename());
for (int i = 0; i < population->GetWorldX(); i++) {
  for (int j = 0; j < population->GetWorldY(); j++) {
    cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
    int id = (cell.IsOccupied()) ?
	 cell.GetOrganism()->GetGenotype()->GetID() : -1;
    fp << id << " ";
  }
  fp << endl;
}

dump_task_grid
:descr:
/**
* Writes out a grid of tasks done by each organism
* Tasks are encoded as a binary string first, and then converted into a
* base 10 number 
**/
:args:
:body:
cString filename;
filename.Set("task_grid_%d.dat",population->GetUpdate());
ofstream fp(filename());
cAnalyzeUtil::TaskGrid( population, fp );

/**
* Writes out tasks done for all current organisms
* output is the base 10 representation of 0-1 binary strings
* representing the all tasks done, with NOT = 2^0, EQU = 2^8
*
* The output file is called "task_grid.*.out", where '*' is replaced by the
* number of the current update.
**/

dump_donor_grid
:descr:
/**
* Writes out the grid of donor organisms in the population
* 
* The output file is called "donor_grid.*.out", where '*' is replaced by the
* number of the current update.
**/   
:args:
:body:
cString filename;
filename.Set("donor_grid.%05d.out", population->GetUpdate());
ofstream fp(filename());
for (int i = 0; i < population->GetWorldX(); i++) {  
  for (int j = 0; j < population->GetWorldY(); j++) {
    cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
    int donor = cell.IsOccupied() ?  
       cell.GetOrganism()->GetPhenotype().IsDonorLast() : -1;    
    fp << donor << " ";
  }
  fp << endl;
}

dump_receiver_grid
:descr:
/**
* Writes out the grid of organisms which received merit in the population
*
* The output file is called "receiver_grid.*.out", where '*' is replaced by the
* number of the current update.
**/
:args:
:body:
cString filename;
filename.Set("receiver_grid.%05d.out", population->GetUpdate());
ofstream fp(filename());
for (int i = 0; i < population->GetWorldX(); i++) {
  for (int j = 0; j < population->GetWorldY(); j++) {
    cPopulationCell & cell = population->GetCell(j*population->GetWorldX()+i);
    int receiver = cell.IsOccupied() ?
       cell.GetOrganism()->GetPhenotype().IsReceiver() : -1;
    fp << receiver << " ";
  }
  fp << endl;
}


######### Tree Reconstruction ##########
print_tree_depths
:descr:
/**
* Reconstruction of phylogenetic trees.
**/
:args:
cString filename ""
:body:
if (filename == "") filename.Set("tree_depth.%d.dat", population->GetUpdate());
ofstream fp(filename);
cAnalyzeUtil::PrintTreeDepths(population, fp);


########## Grid Structure ############
sever_grid_col
:descr:
/**
* Remove the connections between cells along a column in an avida grid.
* Arguments:
*  col_id:  indicates the number of columns to the left of the cut.
*           default (or -1) = cut population in half
*  min_row: First row to start cutting from
*           default = 0
*  max_row: Last row to cut to
*           default (or -1) = last row in population.
**/
:args:
int col_id -1
int min_row 0
int max_row -1
:body:
const int world_x = population->GetWorldX();
const int world_y = population->GetWorldY();
if (col_id == -1) col_id = world_x / 2;
if (max_row == -1) max_row = world_y;
if (col_id < 0 || col_id >= world_x) {
  cerr << "Event Error: Column ID " << col_id
       << " out of range for sever_grid_col" << endl;
  return;
}
// Loop through all of the rows and make the cut on each...
for (int row_id = min_row; row_id < max_row; row_id++) {
  int idA = row_id * world_x + col_id;
  int idB  = GridNeighbor(idA, world_x, world_y, -1,  0);
  int idA0 = GridNeighbor(idA, world_x, world_y,  0, -1);
  int idA1 = GridNeighbor(idA, world_x, world_y,  0,  1);
  int idB0 = GridNeighbor(idA, world_x, world_y, -1, -1);
  int idB1 = GridNeighbor(idA, world_x, world_y, -1,  1);
  cPopulationCell & cellA = population->GetCell(idA);
  cPopulationCell & cellB = population->GetCell(idB);
  tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
  tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
  cellA_list.Remove(&population->GetCell(idB));
  cellA_list.Remove(&population->GetCell(idB0));
  cellA_list.Remove(&population->GetCell(idB1));
  cellB_list.Remove(&population->GetCell(idA));
  cellB_list.Remove(&population->GetCell(idA0));
  cellB_list.Remove(&population->GetCell(idA1));
}

sever_grid_row
:descr:
/**
* Remove the connections between cells along a column in an avida grid.
* Arguments:
*  row_id:  indicates the number of rows above the cut.
*           default (or -1) = cut population in half
*  min_col: First row to start cutting from
*           default = 0
*  max_col: Last row to cut to
*           default (or -1) = last row in population.
**/
:args:
int row_id -1
int min_col 0
int max_col -1
:body:
const int world_x = population->GetWorldX();
const int world_y = population->GetWorldY();
if (row_id == -1) row_id = world_y / 2;
if (max_col == -1) max_col = world_x;
if (row_id < 0 || row_id >= world_y) {
  cerr << "Event Error: Row ID " << row_id
       << " out of range for sever_grid_row" << endl;
  return;
}
// Loop through all of the cols and make the cut on each...
for (int col_id = min_col; col_id < max_col; col_id++) {
  int idA = row_id * world_x + col_id;
  int idB  = GridNeighbor(idA, world_x, world_y,  0, -1);
  int idA0 = GridNeighbor(idA, world_x, world_y, -1,  0);
  int idA1 = GridNeighbor(idA, world_x, world_y,  1,  0);
  int idB0 = GridNeighbor(idA, world_x, world_y, -1, -1);
  int idB1 = GridNeighbor(idA, world_x, world_y,  1, -1);
  cPopulationCell & cellA = population->GetCell(idA);
  cPopulationCell & cellB = population->GetCell(idB);
  tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
  tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
  cellA_list.Remove(&population->GetCell(idB));
  cellA_list.Remove(&population->GetCell(idB0));
  cellA_list.Remove(&population->GetCell(idB1));
  cellB_list.Remove(&population->GetCell(idA));
  cellB_list.Remove(&population->GetCell(idA0));
  cellB_list.Remove(&population->GetCell(idA1));
}

join_grid_col
:descr:
/**
* Join the connections between cells along a column in an avida grid.
* Arguments:
*  col_id:  indicates the number of columns to the left of the joining.
*           default (or -1) = join population halves.
*  min_row: First row to start joining from
*           default = 0
*  max_row: Last row to join to
*           default (or -1) = last row in population.
**/
:args:
int col_id -1
int min_row 0
int max_row -1
:body:
const int world_x = population->GetWorldX();
const int world_y = population->GetWorldY();
if (col_id == -1) col_id = world_x / 2;
if (max_row == -1) max_row = world_y;
if (col_id < 0 || col_id >= world_x) {
  cerr << "Event Error: Column ID " << col_id
       << " out of range for join_grid_col" << endl;
  return;
}
// Loop through all of the rows and make the cut on each...
for (int row_id = min_row; row_id < max_row; row_id++) {
  int idA = row_id * world_x + col_id;
  int idB  = GridNeighbor(idA, world_x, world_y, -1,  0);
  cPopulationCell & cellA = population->GetCell(idA);
  cPopulationCell & cellB = population->GetCell(idB);
  cPopulationCell & cellA0 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y,  0, -1));
  cPopulationCell & cellA1 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y,  0,  1));
  cPopulationCell & cellB0 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y, -1, -1));
  cPopulationCell & cellB1 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y, -1,  1));
  tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
  tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
  if (cellA_list.FindPtr(&cellB)  == NULL) cellA_list.Push(&cellB);
  if (cellA_list.FindPtr(&cellB0) == NULL) cellA_list.Push(&cellB0);
  if (cellA_list.FindPtr(&cellB1) == NULL) cellA_list.Push(&cellB1);
  if (cellB_list.FindPtr(&cellA)  == NULL) cellB_list.Push(&cellA);
  if (cellB_list.FindPtr(&cellA0) == NULL) cellB_list.Push(&cellA0);
  if (cellB_list.FindPtr(&cellA1) == NULL) cellB_list.Push(&cellA1);
}

join_grid_row
:descr:
/**
* Remove the connections between cells along a column in an avida grid.
* Arguments:
*  row_id:  indicates the number of rows abovef the cut.
*           default (or -1) = cut population in half
*  min_col: First row to start cutting from
*           default = 0
*  max_col: Last row to cut to
*           default (or -1) = last row in population.
**/
:args:
int row_id -1
int min_col 0
int max_col -1
:body:
const int world_x = population->GetWorldX();
const int world_y = population->GetWorldY();
if (row_id == -1) row_id = world_y / 2;
if (max_col == -1) max_col = world_x;
if (row_id < 0 || row_id >= world_y) {
  cerr << "Event Error: Row ID " << row_id
       << " out of range for join_grid_row" << endl;
  return;
}
// Loop through all of the cols and make the cut on each...
for (int col_id = min_col; col_id < max_col; col_id++) {
  int idA = row_id * world_x + col_id;
  int idB  = GridNeighbor(idA, world_x, world_y,  0, -1);
  cPopulationCell & cellA = population->GetCell(idA);
  cPopulationCell & cellB = population->GetCell(idB);
  cPopulationCell & cellA0 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y, -1,  0));
  cPopulationCell & cellA1 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y,  1,  0));
  cPopulationCell & cellB0 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y, -1, -1));
  cPopulationCell & cellB1 =
	 population->GetCell(GridNeighbor(idA, world_x, world_y,  1, -1));
  tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
  tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
  if (cellA_list.FindPtr(&cellB)  == NULL) cellA_list.Push(&cellB);
  if (cellA_list.FindPtr(&cellB0) == NULL) cellA_list.Push(&cellB0);
  if (cellA_list.FindPtr(&cellB1) == NULL) cellA_list.Push(&cellB1);
  if (cellB_list.FindPtr(&cellA)  == NULL) cellB_list.Push(&cellA);
  if (cellB_list.FindPtr(&cellA0) == NULL) cellB_list.Push(&cellA0);
  if (cellB_list.FindPtr(&cellA1) == NULL) cellB_list.Push(&cellA1);
}

connect_cells
:descr:
/**
* Connects a pair of specified cells.
* Arguments:
*  cellA_x, cellA_y, cellB_x, cellB_y
**/
:args:
int cellA_x
int cellA_y
int cellB_x
int cellB_y
:body:
const int world_x = population->GetWorldX();
const int world_y = population->GetWorldY();
if (cellA_x < 0 || cellA_x >= world_x ||
    cellA_y < 0 || cellA_y >= world_y ||
    cellB_x < 0 || cellB_x >= world_x ||
    cellB_y < 0 || cellB_y >= world_y) {
  cerr << "Event 'connect_cells' cell out of range." << endl;
  return;
}
int idA = cellA_y * world_x + cellA_x;
int idB = cellB_y * world_x + cellB_x;
cPopulationCell & cellA = population->GetCell(idA);
cPopulationCell & cellB = population->GetCell(idB);
tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
cellA_list.PushRear(&cellB);
cellB_list.PushRear(&cellA);

disconnect_cells
:descr:
/**
* Connects a pair of specified cells.
* Arguments:
*  cellA_x, cellA_y, cellB_x, cellB_y
**/
:args:
int cellA_x
int cellA_y
int cellB_x
int cellB_y
:body:
const int world_x = population->GetWorldX();
const int world_y = population->GetWorldY();
if (cellA_x < 0 || cellA_x >= world_x ||
    cellA_y < 0 || cellA_y >= world_y ||
    cellB_x < 0 || cellB_x >= world_x ||
    cellB_y < 0 || cellB_y >= world_y) {
  cerr << "Event 'connect_cells' cell out of range." << endl;
  return;
}
int idA = cellA_y * world_x + cellA_x;
int idB = cellB_y * world_x + cellB_x;
cPopulationCell & cellA = population->GetCell(idA);
cPopulationCell & cellB = population->GetCell(idB);
tList<cPopulationCell> & cellA_list = cellA.ConnectionList();
tList<cPopulationCell> & cellB_list = cellB.ConnectionList();
cellA_list.Remove(&cellB);
cellB_list.Remove(&cellA);

########## Resources ############
inject_resource
:descr:
/**
* Inject (add) a specified amount of a specified resource.
**/
:args:
cString res_name
double res_count
:body:
cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
int res_id = res_lib.GetResource(res_name)->GetID();
population->UpdateResource(res_id, res_count);

set_resource
:descr:
/**
* Set the resource amount to a specific level
**/
:args:
cString res_name
double res_count
:body:
cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
cResource * found_resource = res_lib.GetResource(res_name);
if (found_resource != NULL) {
  population->SetResource(found_resource->GetID(), res_count);
}

inject_scaled_resource
:descr:
/**
* Inject (add) a specified amount of a specified resource, scaled by
* the current average merit divided by the average time slice.
**/
:args:
cString res_name
double res_count
:body:
double ave_merit = population->GetStats().SumMerit().Average();
if ( ave_merit <= 0 )
  ave_merit = 1; // make sure that we don't get NAN's or negative numbers
ave_merit /= cConfig::GetAveTimeslice();
cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
int res_id = res_lib.GetResource(res_name)->GetID();
population->UpdateResource(res_id, res_count/ave_merit);


outflow_scaled_resource
:descr:
/**
* Removes a specified percentage of a specified resource, scaled by
* the current average merit divided by the average time slice.
**/
:args:
cString res_name
double res_perc
:body:
double ave_merit = population->GetStats().SumMerit().Average();
if ( ave_merit <= 0 )
  ave_merit = 1; // make sure that we don't get NAN's or negative numbers
ave_merit /= cConfig::GetAveTimeslice();
cResourceLib & res_lib = population->GetEnvironment().GetResourceLib();
int res_id = res_lib.GetResource(res_name)->GetID();
double res_level = population->GetResource(res_id);
// a quick calculation shows that this formula guarantees that
// the equilibrium level when resource is not used is independent
// of the average merit
double scaled_perc = 1/(1+ave_merit*(1-res_perc)/res_perc);
res_level -= res_level*scaled_perc;
population->SetResource(res_id, res_level);


set_reaction_value
:descr:
/**
* Set the value associated with a reaction to a specific level
**/
:args:
cString reaction_name
double reaction_value
:body:
population->GetEnvironment().SetReactionValue(reaction_name, reaction_value);

set_reaction_value_mult
:descr:
/**
* Change the value of the reaction by multiplying it with the imput number
**/
:args:
cString reaction_name
double value_mult
:body:
population->GetEnvironment().SetReactionValueMult(reaction_name, value_mult);

set_reaction_inst
:descr:
/**
* Change the instruction triggered by the task **/
:args:
cString reaction_name
cString inst_name
:body:
population->GetEnvironment().SetReactionInst(reaction_name, inst_name);

