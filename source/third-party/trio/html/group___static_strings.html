<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
 <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
 <title>TRIO</title>
 <link href="trio.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.2.12 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; </center>
<hr><h1>Static String Functions.</h1>Replacements for the standard C string functions. 
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a0">trio_create</a> (size_t size)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create new string.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a1">trio_destroy</a> (char *string)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Destroy string.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a2">trio_length</a> (const char *string)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Count the number of characters in a string.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a4">trio_append</a> (char *target, const char *source)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Append <code>source</code> at the end of <code>target</code>.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a5">trio_append_max</a> (char *target, size_t max, const char *source)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Append at most <code>max</code> characters from <code>source</code> to <code>target</code>.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a6">trio_contains</a> (const char *string, const char *substring)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determine if a string contains a substring.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a7">trio_copy</a> (char *target, const char *source)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copy <code>source</code> to <code>target</code>.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a8">trio_copy_max</a> (char *target, size_t max, const char *source)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Copy at most <code>max</code> characters from <code>source</code> to <code>target</code>.</em> <a href="#a8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a9">trio_duplicate</a> (const char *source)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Duplicate <code>source</code>.</em> <a href="#a9">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a10">trio_duplicate_max</a> (const char *source, size_t max)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Duplicate at most <code>max</code> characters of <code>source</code>.</em> <a href="#a10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a11">trio_equal</a> (const char *first, const char *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare if two strings are equal.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a12">trio_equal_case</a> (const char *first, const char *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare if two strings are equal.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a13">trio_equal_case_max</a> (const char *first, size_t max, const char *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare if two strings up until the first <code>max</code> characters are equal.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a14">trio_equal_locale</a> (const char *first, const char *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare if two strings are equal.</em> <a href="#a14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a15">trio_equal_max</a> (const char *first, size_t max, const char *second)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare if two strings up until the first <code>max</code> characters are equal.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a16">trio_error</a> (int error_number)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Provide a textual description of an error code (errno).</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a17">trio_format_date_max</a> (char *target, size_t max, const char *format, const struct tm *datetime)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Format the date/time according to <code>format</code>.</em> <a href="#a17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a18">trio_hash</a> (const char *string, int type)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Calculate a hash value for a string.</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a19">trio_index</a> (const char *string, int character)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Find first occurrence of a character in a string.</em> <a href="#a19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a20">trio_index_last</a> (const char *string, int character)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Find last occurrence of a character in a string.</em> <a href="#a20">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a21">trio_lower</a> (char *target)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Convert the alphabetic letters in the string to lower-case.</em> <a href="#a21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a22">trio_match</a> (const char *string, const char *pattern)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare two strings using wildcards.</em> <a href="#a22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a23">trio_match_case</a> (const char *string, const char *pattern)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compare two strings using wildcards.</em> <a href="#a23">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a24">trio_span_function</a> (char *target, const char *source, int(*Function)(int))</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a function on each character in string.</em> <a href="#a24">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a25">trio_substring</a> (const char *string, const char *substring)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Search for a substring in a string.</em> <a href="#a25">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a26">trio_substring_max</a> (const char *string, size_t max, const char *substring)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Search for a substring in the first <code>max</code> characters of a string.</em> <a href="#a26">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a27">trio_tokenize</a> (char *string, const char *delimiters)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Tokenize string.</em> <a href="#a27">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>double&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a28">trio_to_double</a> (const char *source, const char **endp)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Convert string to floating-point number.</em> <a href="#a28">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>float&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a29">trio_to_float</a> (const char *source, const char **endp)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Convert string to floating-point number.</em> <a href="#a29">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>long&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a30">trio_to_long</a> (const char *string, char **endp, int base)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Convert string to signed integer.</em> <a href="#a30">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a31">trio_to_unsigned_long</a> (const char *string, char **endp, int base)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Convert string to unsigned integer.</em> <a href="#a31">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group___static_strings.html#a32">trio_upper</a> (char *target)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Convert the alphabetic letters in the string to upper-case.</em> <a href="#a32">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Replacements for the standard C string functions.
<p>
<b>SYNOPSIS</b>
<p>
<div class="fragment"><pre>
cc ... -ltrio -lm

#include &lt;triostr.h&gt;
</pre></div>
<p>
<b>DESCRIPTION</b>
<p>
This package renames, fixes, and extends the standard C string handling functions.
<p>
<b>Naming</b>
<p>
Renaming is done to provide more clear names, to provide a consistant naming and argument policy, and to hide portability issues.
<p>
<ul>
<li> All functions starts with "trio_". <li> Target is always the first argument, if present, except where the target is optional, such as <a class="el" href="group___static_strings.html#a28">trio_to_double</a>. <li> Functions requiring a size for target includes "_max" in its name, and the size is always the second argument. <li> Functions performing case-sensitive operations includes "_case" in its name.</ul>
<b>Fixing</b>
<p>
Fixing is done to avoid subtle error conditions. For example, <code>strncpy</code> does not terminate the result with a zero if the source string is bigger than the maximal length, so technically the result is not a C string anymore. <a class="el" href="group___static_strings.html#a8">trio_copy_max</a> makes sure that the result is zero terminated.
<p>
<b>Extending</b>
<p>
Extending is done to provide a richer set of fundamental functions. This includes functionality such as wildcard matching ( <code>trio_match</code> ) and calculation of hash values ( <code>trio_hash</code> ). <hr><h2>Function Documentation</h2>
<a name="a4" doxytag="triostr.c::trio_append"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_append </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Append <code>source</code> at the end of <code>target</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
Target string. </td></tr>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure.</dl><dl compact><dt><b>
Precondition: </b><dd>
<code>target</code> must point to a memory chunk with sufficient room to contain the <code>target</code> string and <code>source</code> string. <dd>
No boundary checking is performed, so insufficient memory will result in a buffer overrun. </dl><dl compact><dt><b>
Postcondition: </b><dd>
<code>target</code> will be zero terminated. </dl>    </td>
  </tr>
</table>
<a name="a5" doxytag="triostr.c::trio_append_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_append_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Append at most <code>max</code> characters from <code>source</code> to <code>target</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
Target string. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum number of characters to append. </td></tr>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure.</dl><dl compact><dt><b>
Precondition: </b><dd>
<code>target</code> must point to a memory chuck with sufficient room to contain the <code>target</code> string and the <code>source</code> string (at most <code>max</code> characters). <dd>
No boundary checking is performed, so insufficient memory will result in a buffer overrun. </dl><dl compact><dt><b>
Postcondition: </b><dd>
<code>target</code> will be zero terminated. </dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="triostr.c::trio_contains"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_contains </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>substring</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine if a string contains a substring.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>substring</em>&nbsp;</td><td>
String to be found. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure. </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="triostr.c::trio_copy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_copy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy <code>source</code> to <code>target</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
Target string. </td></tr>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure.</dl><dl compact><dt><b>
Precondition: </b><dd>
<code>target</code> must point to a memory chunk with sufficient room to contain the <code>source</code> string. <dd>
No boundary checking is performed, so insufficient memory will result in a buffer overrun. </dl><dl compact><dt><b>
Postcondition: </b><dd>
<code>target</code> will be zero terminated. </dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="triostr.c::trio_copy_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_copy_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy at most <code>max</code> characters from <code>source</code> to <code>target</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
Target string. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum number of characters to append. </td></tr>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure.</dl><dl compact><dt><b>
Precondition: </b><dd>
<code>target</code> must point to a memory chunk with sufficient room to contain the <code>source</code> string (at most <code>max</code> characters). <dd>
No boundary checking is performed, so insufficient memory will result in a buffer overrun. </dl><dl compact><dt><b>
Postcondition: </b><dd>
<code>target</code> will be zero terminated. </dl>    </td>
  </tr>
</table>
<a name="a0" doxytag="triostr.c::trio_create"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create new string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>size</em>&nbsp;</td><td>
Size of new string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Pointer to string, or NULL if allocation failed. </dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="triostr.c::trio_destroy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void trio_destroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>string</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be freed. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="triostr.c::trio_duplicate"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_duplicate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>source</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Duplicate <code>source</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
A copy of the <code>source</code> string.</dl><dl compact><dt><b>
Postcondition: </b><dd>
<code>target</code> will be zero terminated. </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="triostr.c::trio_duplicate_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_duplicate_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Duplicate at most <code>max</code> characters of <code>source</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum number of characters to duplicate. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
A copy of the <code>source</code> string.</dl><dl compact><dt><b>
Postcondition: </b><dd>
<code>target</code> will be zero terminated. </dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="triostr.c::trio_equal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_equal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare if two strings are equal.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>first</em>&nbsp;</td><td>
First string. </td></tr>
<tr><td valign=top><em>second</em>&nbsp;</td><td>
Second string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean indicating whether the two strings are equal or not.</dl>Case-insensitive comparison.     </td>
  </tr>
</table>
<a name="a12" doxytag="triostr.c::trio_equal_case"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_equal_case </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare if two strings are equal.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>first</em>&nbsp;</td><td>
First string. </td></tr>
<tr><td valign=top><em>second</em>&nbsp;</td><td>
Second string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean indicating whether the two strings are equal or not.</dl>Case-sensitive comparison.     </td>
  </tr>
</table>
<a name="a13" doxytag="triostr.c::trio_equal_case_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_equal_case_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare if two strings up until the first <code>max</code> characters are equal.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>first</em>&nbsp;</td><td>
First string. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum number of characters to compare. </td></tr>
<tr><td valign=top><em>second</em>&nbsp;</td><td>
Second string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean indicating whether the two strings are equal or not.</dl>Case-sensitive comparison.     </td>
  </tr>
</table>
<a name="a14" doxytag="triostr.c::trio_equal_locale"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_equal_locale </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare if two strings are equal.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>first</em>&nbsp;</td><td>
First string. </td></tr>
<tr><td valign=top><em>second</em>&nbsp;</td><td>
Second string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean indicating whether the two strings are equal or not.</dl>Collating characters are considered equal.     </td>
  </tr>
</table>
<a name="a15" doxytag="triostr.c::trio_equal_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_equal_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>second</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare if two strings up until the first <code>max</code> characters are equal.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>first</em>&nbsp;</td><td>
First string. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum number of characters to compare. </td></tr>
<tr><td valign=top><em>second</em>&nbsp;</td><td>
Second string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean indicating whether the two strings are equal or not.</dl>Case-insensitive comparison.     </td>
  </tr>
</table>
<a name="a16" doxytag="triostr.c::trio_error"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* trio_error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>error_number</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provide a textual description of an error code (errno).
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>error_number</em>&nbsp;</td><td>
Error number. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Textual description of <code>error_number</code>. </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="triostr.c::trio_format_date_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t trio_format_date_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>format</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const struct tm *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>datetime</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format the date/time according to <code>format</code>.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
Target string. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum number of characters to format. </td></tr>
<tr><td valign=top><em>format</em>&nbsp;</td><td>
Formatting string. </td></tr>
<tr><td valign=top><em>datetime</em>&nbsp;</td><td>
Date/time structure. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of formatted characters.</dl>The formatting string accepts the same specifiers as the standard C function strftime.     </td>
  </tr>
</table>
<a name="a18" doxytag="triostr.c::trio_hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long trio_hash </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate a hash value for a string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be calculated on. </td></tr>
<tr><td valign=top><em>type</em>&nbsp;</td><td>
Hash function. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Calculated hash value.</dl><code>type</code> can be one of the following <ul>
<li> <code>TRIO_HASH_PLAIN</code> Plain hash function. </ul>
    </td>
  </tr>
</table>
<a name="a19" doxytag="triostr.c::trio_index"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_index </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>character</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find first occurrence of a character in a string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>character</em>&nbsp;</td><td>
Character to be found. </td></tr>
<tr><td valign=top><em>A</em>&nbsp;</td><td>
pointer to the found character, or NULL if character was not found. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a20" doxytag="triostr.c::trio_index_last"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_index_last </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>character</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find last occurrence of a character in a string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>character</em>&nbsp;</td><td>
Character to be found. </td></tr>
<tr><td valign=top><em>A</em>&nbsp;</td><td>
pointer to the found character, or NULL if character was not found. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="triostr.c::trio_length"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t trio_length </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>string</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Count the number of characters in a string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to measure. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of characters in @string. </dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="triostr.c::trio_lower"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_lower </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>target</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert the alphabetic letters in the string to lower-case.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
String to be converted. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of processed characters (converted or not). </dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="triostr.c::trio_match"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_match </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pattern</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare two strings using wildcards.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>pattern</em>&nbsp;</td><td>
Pattern, including wildcards, to search for. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure.</dl>Case-insensitive comparison.
<p>
The following wildcards can be used <ul>
<li> <code>*</code> Match any number of characters. <li> ? <code>Match</code> a single character. </ul>
    </td>
  </tr>
</table>
<a name="a23" doxytag="triostr.c::trio_match_case"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_match_case </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>pattern</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare two strings using wildcards.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>pattern</em>&nbsp;</td><td>
Pattern, including wildcards, to search for. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Boolean value indicating success or failure.</dl>Case-sensitive comparison.
<p>
The following wildcards can be used <ul>
<li> <code>*</code> Match any number of characters. <li> ? <code>Match</code> a single character. </ul>
    </td>
  </tr>
</table>
<a name="a24" doxytag="triostr.c::trio_span_function"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t trio_span_function </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int(*&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>Function</em>)(int)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a function on each character in string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
Target string. </td></tr>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
Source string. </td></tr>
<tr><td valign=top><em>Function</em>&nbsp;</td><td>
Function to be executed. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of processed characters. </dl>    </td>
  </tr>
</table>
<a name="a25" doxytag="triostr.c::trio_substring"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_substring </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>substring</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search for a substring in a string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>substring</em>&nbsp;</td><td>
String to be found. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Pointer to first occurrence of <code>substring</code> in <code>string</code>, or NULL if no match was found. </dl>    </td>
  </tr>
</table>
<a name="a26" doxytag="triostr.c::trio_substring_max"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_substring_max </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>max</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>substring</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search for a substring in the first <code>max</code> characters of a string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be searched. </td></tr>
<tr><td valign=top><em>max</em>&nbsp;</td><td>
Maximum characters to be searched. </td></tr>
<tr><td valign=top><em>substring</em>&nbsp;</td><td>
String to be found. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Pointer to first occurrence of <code>substring</code> in <code>string</code>, or NULL if no match was found. </dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="triostr.c::trio_to_double"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double trio_to_double </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>endp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert string to floating-point number.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
String to be converted. </td></tr>
<tr><td valign=top><em>endp</em>&nbsp;</td><td>
Pointer to end of the converted string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
A floating-point number.</dl>The following Extended Backus-Naur form is used <div class="fragment"><pre>
   double        ::= [ &lt;sign&gt; ]
                     ( &lt;number&gt; |
                       &lt;number&gt; &lt;decimal_point&gt; &lt;number&gt; |
                       &lt;decimal_point&gt; &lt;number&gt; )
                     [ &lt;exponential&gt; [ &lt;sign&gt; ] &lt;number&gt; ]
   number        ::= 1*( &lt;digit&gt; )
   digit         ::= ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )
   exponential   ::= ( 'e' | 'E' )
   sign          ::= ( '-' | '+' )
   decimal_point ::= '.'
   </pre></div>     </td>
  </tr>
</table>
<a name="a29" doxytag="triostr.c::trio_to_float"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float trio_to_float </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>source</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>endp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert string to floating-point number.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>source</em>&nbsp;</td><td>
String to be converted. </td></tr>
<tr><td valign=top><em>endp</em>&nbsp;</td><td>
Pointer to end of the converted string. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
A floating-point number.</dl>See <a class="el" href="group___static_strings.html#a28">trio_to_double</a>.     </td>
  </tr>
</table>
<a name="a30" doxytag="triostr.c::trio_to_long"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long trio_to_long </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>endp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>base</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert string to signed integer.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be converted. </td></tr>
<tr><td valign=top><em>endp</em>&nbsp;</td><td>
Pointer to end of converted string. </td></tr>
<tr><td valign=top><em>base</em>&nbsp;</td><td>
Radix number of number. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a31" doxytag="triostr.c::trio_to_unsigned_long"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> unsigned long trio_to_unsigned_long </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>endp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>base</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert string to unsigned integer.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be converted. </td></tr>
<tr><td valign=top><em>endp</em>&nbsp;</td><td>
Pointer to end of converted string. </td></tr>
<tr><td valign=top><em>base</em>&nbsp;</td><td>
Radix number of number. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="triostr.c::trio_tokenize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* trio_tokenize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>string</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>delimiters</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tokenize string.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>string</em>&nbsp;</td><td>
String to be tokenized. </td></tr>
<tr><td valign=top><em>tokens</em>&nbsp;</td><td>
String containing list of delimiting characters. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Start of new token.</dl><dl compact><dt><b>
Warning: </b><dd>
<code>string</code> will be destroyed. </dl>    </td>
  </tr>
</table>
<a name="a32" doxytag="triostr.c::trio_upper"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int trio_upper </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>target</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert the alphabetic letters in the string to upper-case.
<p>
<dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>target</em>&nbsp;</td><td>
The string to be converted. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
The number of processed characters (converted or not). </dl>    </td>
  </tr>
</table>
<HR>
<center class="copyright">Copyright (C) 2001 Bj&oslash;rn Reese and Daniel Stenberg.</center>
</body>
</html>
